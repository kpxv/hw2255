\documentclass[CMPE]{KGCOEReport}

\usepackage{graphicx}
\usepackage{newtxtext, newtxmath}
\usepackage{csquotes}
\usepackage{parskip}
\usepackage{karnaugh-map}
\usepackage{float}
\usepackage{pdfpages}

\graphicspath{{./assets/}}

\newcommand{\classCode}{CMPE 260}
\newcommand{\name}{Aden Perry}
\newcommand{\LabSectionNum}{L2}
\newcommand{\LabInstructor}{Richard Cliver}

\newcommand{\TAs}{Eric Reed \\ Oliver Merliss \\ Pietro Paniccia \\ Tevin Hendess}
\newcommand{\LectureSectionNum}{01}
\newcommand{\LectureInstructor}{Cory Merkel}
\newcommand{\exerciseNumber}{2}
\newcommand{\exerciseDescription}{Defining a Simple Register File}
\newcommand{\dateDone}{2026-01-21}
\newcommand{\dateSubmitted}{2026-02-10}

\begin{document}

\maketitle

\section*{Abstract}

The purpose of this exercise was to design and implement a register containing
$2^3$ (i.e.\ 8) register modules, each consisting of 8 bits. The design was
implemented using generics and arrays to allow for scalability. A test bench 
was written to test all basic functions of the register file, including write
enable functionality; register 0 immutability; I/O functionality for 
various registers; and read functionality for both output buses. The register
file was simulated and tested against the test bench. The register file was
flashed to a Basys3 FPGA and stimulated manually. All test cases passed and 
manual stimulations gave expected results, so the exercise was a success.

\section*{Design Methodology}

A register file was implemented in VHDL using a generic to describe the bit 
width of each register. The address of each register was given by a bus of bits
equal in length to the $\text{log}_2$ of the number of registers. In fact, only
the length of the bus was specified in VHDL; the number of registers is
inferred to be 2 to the power of the bus length. This allowed each possible
input address to correspond to a single register. The length of the bus was
also specified using a generic.

The bit width was initially specified to be 8 bits, and the $\text{log}_2$ of
the number of register modules was initially specified to be 3. These values
were later changed to 32 and 2, respectively. A bit width of 32 was chosen to
make the register file more applicable to a standard processor. A bus length of
2 was chosen due to constraints on the Basys3; exceeding 2 requires using more
I/O ports than the board has available. Theoretically, with more hardware, a
value such as 5 could have been chosen.

The register file consisted of a register module and the logic required to
write to and read from it. The register module was a series of register buses;
it could be thought of as a \enquote{2-D Array}. The register file asynchronously
mapped the registers specified by \texttt{Addr1} and \texttt{Addr2} to outputs
\texttt{RD1} and \texttt{RD2}, respectively. The register file wrote the data
given in \texttt{wd} to the register specified by \texttt{Addr3} on the falling
edge of the clock, assuming write-enable \texttt{we} was active. The register
at address 0 was made to be immutable; it could not be written to.

\section*{Results and Analysis}

In order to verify the correctness of the register file, a test bench was
created containing 14 tests. Tests were chosen to ensure basic functionality:
reads from any address using either \texttt{RD1} or \texttt{RD2}, writes to any
address except R0, and a write-enable. The waveform generated by a behavioral
simulation against the test bench is given in Figure \ref{fig:behv-tb}.

\begin{figure}[H]
    \center
    \includegraphics[width=\textwidth]{behv-tb-wav}
    \caption{Waveform for the behavioral testbench}
    \label{fig:behv-tb}
\end{figure}

The waveform shown in Figure \ref{fig:behv-tb} shows that the design was
implemented correctly.

For example, the write functionality was tested between 0 ns and 200 ns, as
shown in Figure \ref{fig:behv-write}.

\begin{figure}[H]
    \center
    \includegraphics[width=\textwidth]{behv-write}
    \caption{Waveform for the write test}
    \label{fig:behv-write}
\end{figure}

The waveform given in Figure \ref{fig:behv-write} shows first a write to
register 1 at 0 ns, then a read from register 1 at 100 ns. The test shows that
the write data (\texttt{0x00000010}) matches the read data
(\texttt{0x00000010}). This is the correct behavior for a write operation; the
test passed.

The functionality of the write-enable toggle was tested between 500 ns and 700
ns, as shown in Figure \ref{fig:behv-no-write}.

\begin{figure}[H]
    \center
    \includegraphics[width=\textwidth]{behv-no-write}
    \caption{Waveform for the write-enable test}
    \label{fig:behv-no-write}
\end{figure}

The waveform given in Figure \ref{fig:behv-no-write} shows an attempt to write 
to register 2 while the signal \texttt{we} is inactive at 500 ns. The waveform
then shows the read from register 2 at 600 ns. The read data did not match the
write data; it was unchanged. This is the correct behavior for an attempt write
when \texttt{we} is inactive; the test passed.

The mutability of register 0 was tested between 700 ns and 900 ns, as shown in
Figure \ref{fig:behv-r0-write}.

\begin{figure}[H]
    \center
    \includegraphics[width=\textwidth]{behv-r0-write}
    \caption{Waveform the R0 mutability test}
    \label{fig:behv-r0-write}
\end{figure}

The waveform given in Figure \ref{fig:behv-r0-write} shaws an attempt to write
to register 0 with data \texttt{0x000000FF} at 700 ns. The waveform shows a
read from register 0 at 800 ns. The read data (\texttt{0x00000000}) did not
match the write data (\texttt{0x000000FF}). This is the expected behavior for
an attempt to write to an immutable register; the test passed.

In order to verify that the design could run on hardware, a post-implementation
timing simulation was conducted. The waveform generated by this simulation is
given in Figure \ref{fig:impl-tb}.

\begin{figure}[H]
    \center
    \includegraphics[width=\textwidth]{impl-tb-wav.png}
    \caption{Waveform for the post-implementation testbench}
    \label{fig:impl-tb}
\end{figure}

The waveform shown in Figure \ref{fig:impl-tb} shows that the design would work
on the Basys3 FPGA. It also shows the required time to wait after an input
change before an output signal can be trusted.

For example, the same write function tested in Figure \ref{fig:behv-write} is
tested with post-implementation timing. The waveform is given in Figure
\ref{fig:impl-0ns}.

\begin{figure}[H]
    \center
    \includegraphics[width=\textwidth]{impl-0ns}
    \caption{Waveform for the post-implementation write test}
    \label{fig:impl-0ns}
\end{figure}

The waveform given in \ref{fig:impl-0ns} shows both that the write
functionality works as expected and that a large delay of approximately 11 ns
must occur before the output from \texttt{RD1} or \texttt{RD2} can be trusted.
Examining Figure \ref{fig:impl-tb} and Figure \ref{fig:behv-tb} shows that no
functionality was lost in the implementation stage of simulation. Examining
Figure \ref{fig:impl-tb} and Figure \ref{fig:impl-0ns} shows that a maximum of
11 ns must pass before the output from \texttt{RD1} or \texttt{RD2} can be
trusted.

The testbench was simulated through EDAPlayground to test for errors or
irregularities not caught by the Vivado simulator. The waveform of the
EDAPlayground testbench simulation is given in Figure \ref{fig:edap-tb}.

\begin{figure}[H]
    \center
    \includegraphics[width=\textwidth]{edap-tb}
    \caption{Waveform for the EDAPlayground testbench}
    \label{fig:edap-tb}
\end{figure}

The waveform given in Figure \ref{fig:edap-tb} shows no differences compared to
the behavioral waveform given in Figure \ref{fig:behv-tb}. Therefore,
EDAPlayground did not reveal any irregularities that Vivado did not.

\section*{Conclusion}

The object of the exercise was to design an 8-bit register file containing
$2^3$ using VHDL registers. This was accomplished by using 2-dimensional arrays
and generics to specify sizes. The register file was later expanded to support
32-bit registers, at the expense of register quantity. The exercise was
successful; all test cases were passed. Arrays were shown to be a powerful data
structure in VHDL with a variety of uses, including iteration for test cases
and for mass storage of data. Register files were shown to be easy to
implement. In future exercises, arrays will be used for easy iteration and
testing of test cases.

\includepdf[pages=-]{assets/prelab}
\end{document}
